# More.Tech 5.0 - team Океан.Тэч 

## Алгоритм получения наилучшего отделения / банкомата

Предполагается что на сайте будет возможность выбрать нужные и важные для пользователя условия поиска, а так же выбрать необходимые услуги. Пользователь выбирает нужные ему теги и делает запрос. 
На сервер при этом отправляются: текущие координаты пользователя и радиус который он определи как подходящий ему (возможно тут будет просто константа)
Сервер на основе предпочтений пользователя фильтрует список отделений и банкоматов с условием что координаты попадают в обозначенный радиус и выдает этот short list пользователю

**Киллер фича:** Добавляем в ответ данные ML модели (коллаборативная рекомендательная система user-based & item-based), которая на основе популярности филиала (рейтинге) и на основе содержания запроса показывает самых близких соседей на основе истории посещений пользователя
Данные для обучения модели и расчета были сгенерированы бибдиотекой faker 

## Алгоритм получения загруженности отделений и банкоматов

### Отделения

В качестве источника данных предполагается использовать терминалы электронной очереди расположенные в отделениях. Сервер в фоновом режиме делает их опрос с какой-то периодичностью (например раз в 30 сек) и сохраняет у себя в БД полученные результаты по количеству человек в очереди и среднем времени ожидания. На основе этих данные дается метка по загруженности отделения в текущий момент.

**Киллер фича:** ML модель скользящего среднего временного ряда обучается на архивных данных по количеству человек в очереди. Делаем прогноз на N минут вперед по количеству человек в очереди и умножаем на среднее время ожидания. Таким образом даем пользователю прогнозную информацию на момент его прибытия в точку назначения

## Банкоматы

В качестве источника данных предполагается использовать список транзакций совершенных в банкоматах. Сервер в фоновом режиме делает запрос в процессинг с какой-то периодичностью (например раз в 30 сек) и сохраняет у себя в БД последние 10 записей: id банкомата, id клиента и timestamp последней транзакции. На основании среднего времени простоя между транзакциями делаем предположение о загруженности банкомата в текущий момент.

**Киллер фича:** ML модель скользящего среднего временного ряда обучается на архивных данных по среднему времени простоя между транзакциями. Делаем прогноз на N минут вперед. Таким образом даем пользователю прогнозную информацию на момент его прибытия в точку назначения

## Методы работы с бэкендом

### Получение списка всех банкоматов и отделений

```json
GET /api/v1/typelist
```

```json
Формат ответа:
{
	"totalAtms": 11,
	"totalOffices": 5,
	"atms": {...},
	"offices": {...}
}
```

### Получение всех отделений и банкоматов в радиусе N от текущего положения пользовател

```json
POST /api/v1/typelist
{
	"latitude": 56.184479, // Координаты пользователя
	"longitude": 36.984314, // Координаты пользователя
	"radius": 1, // Радиус в километрах в рамках которого необходимо показать бинкоматы и отделения
	"tags": [
		"wheelchair",
		"blind",
		"nfcForBankCards",
		"qrRead",
		"supportsUsd",
		"supportsRub",
		"supportsEur",
		"supportsChargeRub"
	] // Теги выбранные пользователем
}
```

```json
Формат ответа:
{
	"totalAtms": 11,
	"totalOffices": 5,
	"atms": [
		{
			// все поля как при запросе GET, но дополнительно:
			"load": "low" // загрузка банкомата, возможны: low, middle, high
		}
	],
	"offices": [
		{
			// все поля как при запросе GET, но дополнительно:
			"rating": 4.8, // Рейтинг отделения посчитанный ML моделью
			"load": "middle" // загрузка отделения, возможны: low, middle, high
		}
	]
}
```
## Демонстрационная версия сервиса
```
  UI - https://react-yandex-map-ten.vercel.app
  API - http://hack.torbeno.ru
```

## Стек технологий
Golang 1.20 
 - echo/v5
 - golang-jwt
Python 3.8
 - pandas
 - nympy
 - sklearn (алгоритм k-ближайших соседей, линейная регрессия)

## Запуск локально
```
 $docker compose up
 $make up
 $pip3 install -r /services/predict/requirements.txt
 $make run 
```

## Безопасность

- Для авторизации между компонентами системы используется короткоживущий JWT токен, созданный с использованием секретного ключа. 
- Все входящие данные валидируются и проходят проверку на формат и тип данных, что ипключает SQL инъекции
- Запросы в БД используются предподготовленные, и сохраняются в строго типизированные переменные
- Перед API есть шлюз в виде Nginx, который управляет ограничениями CORS политик, а так же позволяет использовать несколько бэкендов для масштабирования

## Масштабирование

- Приложение имеет микросервисную архитектуру
- Собирается в бинарный файл и затем в docker контейнер. Подготовлено для kubernetes среды
- Может использовать кластерную базу данных при необходимости, с записью в master, а чтением из slave
